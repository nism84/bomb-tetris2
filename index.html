<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
    }
    .game-container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    #game-board {
      width: 300px;
      height: 600px;
      background-color: #111;
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(20, 1fr);
      gap: 1px;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    .cell {
      background-color: #222;
      border-radius: 2px;
    }
    .filled {
      border-radius: 2px;
    }
    .info-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .next-piece-container {
      width: 120px;
      height: 120px;
      background-color: #111;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    #next-piece {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 1px;
    }
    .stats {
      background-color: #111;
      color: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      width: 120px;
    }
    .stats p {
      margin: 5px 0;
    }
    h1 {
      color: #333;
      margin-bottom: 0;
    }
    .controls {
      margin-top: 20px;
      background-color: #111;
      color: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      text-align: center;
    }
    .controls p {
      margin: 5px 0;
    }
    button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 10px 2px;
      cursor: pointer;
      border-radius: 5px;
    }
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      display: none;
    }
    /* ê¸°ì¡´ ë¸”ë¡ ìƒ‰ìƒ */
    .color-0 { background-color: #00f0f0; } /* I */
    .color-1 { background-color: #0000f0; } /* J */
    .color-2 { background-color: #f0a000; } /* L */
    .color-3 { background-color: #f0f000; } /* O */
    .color-4 { background-color: #00f000; } /* S */
    .color-5 { background-color: #a000f0; } /* T */
    .color-6 { background-color: #f00000; } /* Z */
    /* í­íƒ„ ë¸”ë¡ ìƒ‰ìƒ ë° ì• ë‹ˆë©”ì´ì…˜ */
    .color-7 { 
      background-color: #444; 
      background-image: radial-gradient(circle, #444 0%, #000 100%);
      position: relative;
    }
    .color-7::after {
      content: 'ğŸ’£';
      font-size: 15px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    @keyframes explosion {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.8; }
      100% { transform: scale(2); opacity: 0; }
    }
    .exploding {
      background-color: #ff4500;
      animation: explosion 0.5s forwards;
      z-index: 10;
    }
    .explosion-effect {
      position: absolute;
      background: radial-gradient(circle, rgba(255,69,0,1) 0%, rgba(255,165,0,0.8) 50%, rgba(255,255,0,0) 100%);
      border-radius: 50%;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h1>í…ŒíŠ¸ë¦¬ìŠ¤</h1>
  
  <div class="game-container">
    <div id="game-board"></div>
    
    <div class="info-panel">
      <div class="next-piece-container">
        <h3 style="color: white; margin-top: 0;">ë‹¤ìŒ ë¸”ë¡:</h3>
        <div id="next-piece"></div>
      </div>
      
      <div class="stats">
        <h3 style="margin-top: 0;">ì ìˆ˜</h3>
        <p>ë ˆë²¨: <span id="level">1</span></p>
        <p>ì ìˆ˜: <span id="score">0</span></p>
        <p>ë¼ì¸: <span id="lines">0</span></p>
        <p>í­íƒ„: <span id="bombs">0</span></p>
      </div>
      
      <button id="start-button">ê²Œì„ ì‹œì‘</button>
    </div>
  </div>
  
  <div class="controls">
    <h3>ì¡°ì‘ ë°©ë²•</h3>
    <p>â† â†’ : ì¢Œìš° ì´ë™</p>
    <p>â†‘ : íšŒì „</p>
    <p>â†“ : ë¹ ë¥´ê²Œ ë‚´ë¦¬ê¸°</p>
    <p>ìŠ¤í˜ì´ìŠ¤ : ì¦‰ì‹œ ë‚´ë¦¬ê¸°</p>
    <p><strong>ğŸ’£ í­íƒ„ ë¸”ë¡</strong>: ì£¼ë³€ 3x3 ë¸”ë¡ì„ í­ë°œì‹œí‚µë‹ˆë‹¤!</p>
  </div>
  
  <div class="game-over" id="game-over">
    <h2>ê²Œì„ ì˜¤ë²„!</h2>
    <p>ìµœì¢… ì ìˆ˜: <span id="final-score">0</span></p>
    <button id="restart-button">ë‹¤ì‹œ ì‹œì‘</button>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // ê²Œì„ ìƒìˆ˜
      const BOARD_WIDTH = 10;
      const BOARD_HEIGHT = 20;
      const COLORS = [
        'color-0', // I
        'color-1', // J
        'color-2', // L
        'color-3', // O
        'color-4', // S
        'color-5', // T
        'color-6', // Z
        'color-7'  // í­íƒ„
      ];

      // í…ŒíŠ¸ë¡œë¯¸ë…¸ ëª¨ì–‘
      const TETROMINOS = [
        // I
        [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        // J
        [
          [1, 0, 0],
          [1, 1, 1],
          [0, 0, 0]
        ],
        // L
        [
          [0, 0, 1],
          [1, 1, 1],
          [0, 0, 0]
        ],
        // O
        [
          [1, 1],
          [1, 1]
        ],
        // S
        [
          [0, 1, 1],
          [1, 1, 0],
          [0, 0, 0]
        ],
        // T
        [
          [0, 1, 0],
          [1, 1, 1],
          [0, 0, 0]
        ],
        // Z
        [
          [1, 1, 0],
          [0, 1, 1],
          [0, 0, 0]
        ],
        // í­íƒ„ - 1x1 ë¸”ë¡
        [
          [1]
        ]
      ];

      // ê²Œì„ ë³€ìˆ˜
      let board = createBoard();
      let gameInterval;
      let currentPiece;
      let nextPiece;
      let currentPosition = { x: 0, y: 0 };
      let score = 0;
      let lines = 0;
      let level = 1;
      let bombs = 0;
      let gameSpeed = 1000;
      let isGameOver = false;
      let isPaused = false;
      let explosionTimeout = null;

      // DOM ìš”ì†Œ
      const gameBoard = document.getElementById('game-board');
      const nextPieceDisplay = document.getElementById('next-piece');
      const scoreElement = document.getElementById('score');
      const levelElement = document.getElementById('level');
      const linesElement = document.getElementById('lines');
      const bombsElement = document.getElementById('bombs');
      const startButton = document.getElementById('start-button');
      const gameOverDisplay = document.getElementById('game-over');
      const finalScoreDisplay = document.getElementById('final-score');
      const restartButton = document.getElementById('restart-button');

      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      startButton.addEventListener('click', startGame);
      restartButton.addEventListener('click', restartGame);
      document.addEventListener('keydown', handleKeyPress);

      // ê²Œì„ ë³´ë“œ ì´ˆê¸°í™”
      function initializeBoard() {
        gameBoard.innerHTML = '';
        nextPieceDisplay.innerHTML = '';
        
        // ê²Œì„ ë³´ë“œ ì…€ ìƒì„±
        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.x = x;
            cell.dataset.y = y;
            gameBoard.appendChild(cell);
          }
        }
        
        // ë‹¤ìŒ ì¡°ê° ë””ìŠ¤í”Œë ˆì´ ìƒì„±
        for (let y = 0; y < 4; y++) {
          for (let x = 0; x < 4; x++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.x = x;
            cell.dataset.y = y;
            nextPieceDisplay.appendChild(cell);
          }
        }
      }

      // ë¹ˆ ê²Œì„ ë³´ë“œ ìƒì„±
      function createBoard() {
        return Array.from({ length: BOARD_HEIGHT }, () => 
          Array.from({ length: BOARD_WIDTH }, () => 0)
        );
      }

      // ê²Œì„ ì‹œì‘
      function startGame() {
        if (gameInterval) {
          clearInterval(gameInterval);
        }
        
        resetGame();
        initializeBoard();
        
        nextPiece = getRandomPiece();
        createNewPiece();
        
        gameInterval = setInterval(gameLoop, gameSpeed);
        startButton.textContent = 'ì¼ì‹œì •ì§€';
        startButton.removeEventListener('click', startGame);
        startButton.addEventListener('click', togglePause);
      }

      // ê²Œì„ ì¬ì‹œì‘
      function restartGame() {
        gameOverDisplay.style.display = 'none';
        startGame();
      }

      // ê²Œì„ ì´ˆê¸°í™”
      function resetGame() {
        board = createBoard();
        score = 0;
        lines = 0;
        bombs = 0;
        level = 1;
        gameSpeed = 1000;
        isGameOver = false;
        isPaused = false;
        
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
        bombsElement.textContent = bombs;
      }

      // ê²Œì„ ì¼ì‹œì •ì§€ í† ê¸€
      function togglePause() {
        isPaused = !isPaused;
        
        if (isPaused) {
          clearInterval(gameInterval);
          startButton.textContent = 'ê³„ì†í•˜ê¸°';
        } else {
          gameInterval = setInterval(gameLoop, gameSpeed);
          startButton.textContent = 'ì¼ì‹œì •ì§€';
        }
      }

      // ê²Œì„ ë£¨í”„
      function gameLoop() {
        moveDown();
      }

      // ëœë¤ ì¡°ê° ìƒì„± (í­íƒ„ ì¶”ê°€)
      function getRandomPiece() {
        // 10% í™•ë¥ ë¡œ í­íƒ„ ìƒì„± (ë ˆë²¨ì´ ë†’ì„ìˆ˜ë¡ í™•ë¥  ì¦ê°€)
        const bombChance = Math.min(0.1 + (level - 1) * 0.01, 0.2);
        
        if (Math.random() < bombChance) {
          return {
            shape: TETROMINOS[7],
            color: COLORS[7],
            isBomb: true
          };
        }
        
        const pieceIndex = Math.floor(Math.random() * 7); // ì¼ë°˜ ë¸”ë¡ë§Œ (0-6)
        return {
          shape: TETROMINOS[pieceIndex],
          color: COLORS[pieceIndex],
          isBomb: false
        };
      }

      // ìƒˆ ì¡°ê° ìƒì„±
      function createNewPiece() {
        currentPiece = nextPiece;
        nextPiece = getRandomPiece();
        
        // ì‹œì‘ ìœ„ì¹˜ ê³„ì‚°
        currentPosition = {
          x: Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece.shape[0].length / 2),
          y: 0
        };
        
        // ë‹¤ìŒ ì¡°ê° í‘œì‹œ
        drawNextPiece();
        
        // ê²Œì„ ì˜¤ë²„ ì²´í¬
        if (!isValidMove(currentPosition.x, currentPosition.y, currentPiece.shape)) {
          gameOver();
        }
        
        draw();
      }

      // ë‹¤ìŒ ì¡°ê° ê·¸ë¦¬ê¸°
      function drawNextPiece() {
        // ì´ì „ ì¡°ê° ì§€ìš°ê¸°
        const cells = nextPieceDisplay.querySelectorAll('.cell');
        cells.forEach(cell => {
          cell.className = 'cell';
        });
        
        // ìƒˆ ì¡°ê° ê·¸ë¦¬ê¸°
        const piece = nextPiece.shape;
        const color = nextPiece.color;
        
        piece.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value) {
              const cellIndex = y * 4 + x;
              if (cells[cellIndex]) {
                cells[cellIndex].classList.add(color);
              }
            }
          });
        });
      }

      // ë³´ë“œì— ì¡°ê° ê·¸ë¦¬ê¸°
      function draw() {
        // ëª¨ë“  ì…€ ì´ˆê¸°í™”
        const cells = gameBoard.querySelectorAll('.cell');
        cells.forEach(cell => {
          const x = parseInt(cell.dataset.x);
          const y = parseInt(cell.dataset.y);
          
          // ë³´ë“œ ìƒíƒœ ë°˜ì˜
          cell.className = 'cell';
          if (board[y][x]) {
            cell.classList.add(board[y][x]);
          }
        });
        
        // í˜„ì¬ ì¡°ê° ê·¸ë¦¬ê¸°
        currentPiece.shape.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value) {
              const cellX = currentPosition.x + x;
              const cellY = currentPosition.y + y;
              
              if (cellY >= 0 && cellY < BOARD_HEIGHT && cellX >= 0 && cellX < BOARD_WIDTH) {
                const cellIndex = cellY * BOARD_WIDTH + cellX;
                if (cells[cellIndex]) {
                  cells[cellIndex].classList.add(currentPiece.color);
                }
              }
            }
          });
        });
      }

      // ì›€ì§ì„ ê²€ì¦
      function isValidMove(x, y, shape) {
        return shape.every((row, dy) => {
          return row.every((value, dx) => {
            if (!value) return true;
            
            const newX = x + dx;
            const newY = y + dy;
            
            return (
              newX >= 0 &&
              newX < BOARD_WIDTH &&
              newY < BOARD_HEIGHT &&
              (newY < 0 || board[newY][newX] === 0)
            );
          });
        });
      }

      // ì•„ë˜ë¡œ ì´ë™
      function moveDown() {
        const newY = currentPosition.y + 1;
        
        if (isValidMove(currentPosition.x, newY, currentPiece.shape)) {
          currentPosition.y = newY;
          draw();
        } else {
          // ë³´ë“œì— ì¡°ê° ê³ ì •
          lockPiece();
          
          // ì™„ì„±ëœ ì¤„ ì²´í¬ ë° ì œê±°
          checkLines();
          
          // ìƒˆ ì¡°ê° ìƒì„±
          createNewPiece();
        }
      }

      // ì¢Œìš° ì´ë™
      function move(direction) {
        const newX = currentPosition.x + direction;
        
        if (isValidMove(newX, currentPosition.y, currentPiece.shape)) {
          currentPosition.x = newX;
          draw();
        }
      }

      // íšŒì „
      function rotate() {
        // í­íƒ„ ë¸”ë¡ì€ íšŒì „í•˜ì§€ ì•ŠìŒ
        if (currentPiece.isBomb) return;
        
        const newShape = rotateMatrix(currentPiece.shape);
        
        if (isValidMove(currentPosition.x, currentPosition.y, newShape)) {
          currentPiece.shape = newShape;
          draw();
        } else {
          // ë²½ ê·¼ì²˜ì—ì„œ íšŒì „ ì‹œë„
          const kicks = [1, -1, 2, -2];
          
          for (const kick of kicks) {
            if (isValidMove(currentPosition.x + kick, currentPosition.y, newShape)) {
              currentPosition.x += kick;
              currentPiece.shape = newShape;
              draw();
              break;
            }
          }
        }
      }

      // í–‰ë ¬ íšŒì „ (ì‹œê³„ ë°©í–¥)
      function rotateMatrix(matrix) {
        const N = matrix.length;
        const result = Array.from({ length: N }, () => Array(N).fill(0));
        
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < matrix[y].length; x++) {
            result[x][N - 1 - y] = matrix[y][x];
          }
        }
        
        return result;
      }

      // ì¡°ê° ê³ ì •
      function lockPiece() {
        currentPiece.shape.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value) {
              const boardY = currentPosition.y + y;
              const boardX = currentPosition.x + x;
              
              if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                board[boardY][boardX] = currentPiece.color;
                
                // í­íƒ„ ë¸”ë¡ì´ ê³ ì •ë˜ë©´ í­ë°œ
                if (currentPiece.isBomb) {
                  bombs++;
                  bombsElement.textContent = bombs;
                  setTimeout(() => {
                    explodeBomb(boardX, boardY);
                  }, 100);
                }
              }
            }
          });
        });
      }

      // í­íƒ„ í­ë°œ íš¨ê³¼
      function explodeBomb(bombX, bombY) {
        // íš¨ê³¼ìŒ (ì¶”í›„ ì¶”ê°€ ê°€ëŠ¥)
        
        // í­ë°œ ë°˜ê²½: 3x3
        const radius = 1;
        const cells = gameBoard.querySelectorAll('.cell');
        const explodedCells = [];
        
        // í­ë°œ ì• ë‹ˆë©”ì´ì…˜
        const explosionEffect = document.createElement('div');
        explosionEffect.className = 'explosion-effect';
        const cellSize = cells[0].offsetWidth;
        explosionEffect.style.width = `${cellSize * 5}px`;
        explosionEffect.style.height = `${cellSize * 5}px`;
        explosionEffect.style.left = `${bombX * cellSize - cellSize * 2 + 10}px`;
        explosionEffect.style.top = `${bombY * cellSize - cellSize * 2 + 10}px`;
        gameBoard.appendChild(explosionEffect);
        
        setTimeout(() => {
          gameBoard.removeChild(explosionEffect);
        }, 500);
        
        // í­ë°œ ë²”ìœ„ ê³„ì‚°
        for (let y = Math.max(0, bombY - radius); y <= Math.min(BOARD_HEIGHT - 1, bombY + radius); y++) {
          for (let x = Math.max(0, bombX - radius); x <= Math.min(BOARD_WIDTH - 1, bombX + radius); x++) {
            if (board[y][x]) {
              const cellIndex = y * BOARD_WIDTH + x;
              cells[cellIndex].classList.add('exploding');
              explodedCells.push({ x, y });
              
              // ì—°ì‡„ í­ë°œ (ë‹¤ë¥¸ í­íƒ„ì„ í„°ëœ¨ë¦´ ê²½ìš°)
              if (board[y][x] === 'color-7' && (x !== bombX || y !== bombY)) {
                setTimeout(() => {
                  explodeBomb(x, y);
                }, 200);
              }
            }
          }
        }
        
        // í­ë°œ í›„ ë¸”ë¡ ì œê±°
        setTimeout(() => {
          explodedCells.forEach(cell => {
            board[cell.y][cell.x] = 0;
          });
          
          // í­ë°œ í›„ ë¸”ë¡ ì •ë¦¬
          settleBlocks();
          draw();
          
          // í­ë°œ ì ìˆ˜ ì¶”ê°€
          score += explodedCells.length * 10 * level;
          scoreElement.textContent = score;
        }, 500);
      }

      // í­ë°œ í›„ ë¸”ë¡ë“¤ì„ ì•„ë˜ë¡œ ì •ë¦¬
      function settleBlocks() {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          let emptySpaces = 0;
          
          // ì•„ë˜ì—ì„œë¶€í„° ìœ„ë¡œ ê²€ì‚¬
          for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
            if (board[y][x] === 0) {
              emptySpaces++;
            } else if (emptySpaces > 0) {
              // ë¹„ì–´ìˆëŠ” ê³µê°„ì´ ìˆìœ¼ë©´ ë¸”ë¡ì„ ì•„ë˜ë¡œ ì´ë™
              board[y + emptySpaces][x] = board[y][x];
              board[y][x] = 0;
            }
          }
        }
      }

      // ì™„ì„±ëœ ì¤„ ì²´í¬ ë° ì œê±°
      function checkLines() {
        let linesCleared = 0;
        
        for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
          if (board[y].every(cell => cell !== 0)) {
            // ì¤„ ì œê±°
            board.splice(y, 1);
            // ìƒˆ ë¹ˆ ì¤„ ì¶”ê°€
            board.unshift(Array(BOARD_WIDTH).fill(0));
            
            linesCleared++;
            y++; // ê°™ì€ ìœ„ì¹˜ ë‹¤ì‹œ ì²´í¬
          }
        }
        
        if (linesCleared > 0) {
          // ì ìˆ˜ ê³„ì‚°
          updateScore(linesCleared);
        }
      }

      // ì ìˆ˜ ì—…ë°ì´íŠ¸
      function updateScore(linesCleared) {
        const linePoints = [0, 40, 100, 300, 1200]; // 0, 1, 2, 3, 4ì¤„
        
        score += linePoints[linesCleared] * level;
        lines += linesCleared;
        
        // ë ˆë²¨ ì—…
        level = Math.floor(lines / 10) + 1;
        
        // ê²Œì„ ì†ë„ ì—…ë°ì´íŠ¸
        gameSpeed = Math.max(100, 1000 - (level - 1) * 100);
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, gameSpeed);
        
        // UI ì—…ë°ì´íŠ¸
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
      }

      // í•˜ë“œ ë“œë¡­ (ì¦‰ì‹œ ë‚´ë¦¬ê¸°)
      function hardDrop() {
        let newY = currentPosition.y;
        
        while (isValidMove(currentPosition.x, newY + 1, currentPiece.shape)) {
          newY++;
        }
        
        if (newY !== currentPosition.y) {
          currentPosition.y = newY;
          // ì ìˆ˜ ì¶”ê°€ (í•˜ë“œ ë“œë¡­ ê±°ë¦¬ë‹¹ 2ì )
          score += (newY - currentPosition.y) * 2;
          scoreElement.textContent = score;
          
          // ë¸”ë¡ ê³ ì • ë° ë‹¤ìŒ ë‹¨ê³„ ì²˜ë¦¬
          moveDown();
        }
      }

      // ê²Œì„ ì˜¤ë²„
      function gameOver() {
        clearInterval(gameInterval);
        isGameOver = true;
        finalScoreDisplay.textContent = score;
        gameOverDisplay.style.display = 'block';
        startButton.textContent = 'ê²Œì„ ì‹œì‘';
        startButton.removeEventListener('click', togglePause);
        startButton.addEventListener('click', startGame);
      }

      // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
      function handleKeyPress(event) {
        if (isGameOver || isPaused) return;
        
        // í‚¤ ì´ë²¤íŠ¸ ì¤‘ë³µ ë°©ì§€
        event.preventDefault();
        
        switch (event.keyCode) {
          case 37: // ì™¼ìª½ í™”ì‚´í‘œ
            move(-1);
            break;
          case 39: // ì˜¤ë¥¸ìª½ í™”ì‚´í‘œ
            move(1);
            break;
          case 40: // ì•„ë˜ìª½ í™”ì‚´í‘œ
            moveDown();
            break;
          case 38: // ìœ„ìª½ í™”ì‚´í‘œ
            rotate();
            break;
          case 32: // ìŠ¤í˜ì´ìŠ¤ë°”
            hardDrop();
            break;
        }
      }

      // ê²Œì„ ë³´ë“œ ì´ˆê¸°í™”
      initializeBoard();
    });
  </script>
</body>
</html>